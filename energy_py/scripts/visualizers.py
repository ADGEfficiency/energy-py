import logging
import os

import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from energy_py.scripts.utils import Utils, ensure_dir


plt.style.use('seaborn')
matplotlib.rcParams['agg.path.chunksize'] = 10000
logger = logging.getLogger(__name__)

"""
Functions related to generating outputs from agent and environment info
"""

def single_series_fig(series, name, results_path=[],
                      xlabel=[], ylabel=[],
                         xlim='all', ylim=[]):
    """
    args
        series (pd.Series)
        name (str)
        xlabel (str) 
        ylabel (str)
        xlim (str) last_week, last_month or all
        ylim (list) 

    returns
        fig (object) a plot of a single time series
    """
    #  create the matplotlib axes and figure objects
    fig, ax = plt.subplots(1, 1, figsize=(20, 15))
    #  plot as a line
    series.astype(float).plot(kind='line', ax=ax)

    if xlabel:
        plt.xlabel(xlabel)

    if ylabel:
        plt.ylabel(ylabel)

    plt.legend()

    if xlim == 'last_week':
        start = series.index[-7 * 24 * 12]
        end = series.index[-1]

    if xlim == 'last_month':
        start = series.index[-30 * 24 * 12]
        end = series.index[-1]

    if xlim == 'all':
        start = series.index[0]
        end = series.index[-1]

    ax.set_xlim([start, end])

    if ylim:
        ax.set_ylim(ylim)

    #  saving to disk
    if results_path:
        path = os.path.join(results_path, name+'.png')
        ensure_dir(path)
        fig.savefig(path)

    #  attempting to close
    plt.clf()
    plt.cla()
    return fig

def make_panel_fig(df, panels, name, results_path=[],
                   ylabels=[], xlabel=[],
                   ylims=[],
                   kinds=[], errors=[]):
    """
    Creates a panel of time series plots.  
    
    args
        df (pd.DataFrame)
        panels (list) names of the columns to include in each panel
                      is always a list of lists [['col1', 'col2']]
        name (str) name for .png
        ylabels (list) one per panel
        xlabel (str) shared between all panels
        ylims (str) optional limits on the y axis
        kinds (list) option to change type of plot
        errors (list) column names to use as error bars

    returns
        fig (object) plot of the panels
    """
    logger.info('making panel fig for {}'.format(name))
    num_panels = len(panels)

    fig, axes = plt.subplots(nrows=num_panels,
                             ncols=1,
                             figsize=(20, 15),
                             sharex=True)

    axes = np.reshape(axes, -1)
    for i, (ax, panel) in enumerate(zip(axes.flatten(),
                                        panels)):

        for col in panel:
            data = df.loc[:, col]
            
            if kinds:
                kind = kinds[i]
            else:
                kind = 'line'

            data.plot(kind=kind, ax=ax, label=col)

            if errors and errors[i]:
                x = df.index.values
                y = data.values
                error = df.loc[:, errors[i]].values.flatten()
                ax.fill_between(x, y - error, y + error,
                                alpha=0.5)

            if ylims and ylims[i]:
                ax.set_ylim(ylims[i])

            if xlabel:
                xlabels = [xlabel for i in range(num_panels)]
                ax.set_xlabel(xlabels[i])

            if ylabels: 
                assert num_panels == len(ylabels)
                ax.set_ylabel(ylabels[i])

            ax.legend()

        if results_path:
            path = os.path.join(results_path, name+'.png')
            ensure_dir(path)
            fig.savefig(path)

        return fig


class EternityVisualizer(Utils):
    """
    A class to join together data generated by the agent and environment

    args
        agent (object): energy_py Agent class
        env (object): energy_py Env class
        results_path (str):
    """
    def __init__(self,
                 agent=[],
                 env=[],
                 results_path='results/'):

        super().__init__()

        self.results_path = os.path.join(results_path)

        #  option to not run the functionality of the class
        if agent and env:
            self.env = env
            self.agent = agent
            self.master()

    def master(self):
        logger.debug('Pulling data out of the environment')
        self.env_outputs = self.env.output_results()

        #  using the index from state_ts to index the env_info dataframe
        #  we cut the state_ts index to the length of the episode
        index = self.env_outputs['observation_ts'].index
        env_length = self.env_outputs['df_env_info'].shape[0]
        self.env_outputs['df_env_info'].index = index[:env_length]

        logger.debug('Pulling data out of the agent')
        self.agent_outputs = self.agent.output_results()

        #  now we grab the .info dictionaries from both agent and env
        #  and turn them into plots
        agent_series, agent_figs = self.info_to_plots(self.agent_outputs['info'])
        self.agent_outputs['series'] = agent_series
        self.agent_outputs['figs'] = agent_figs

        env_series, env_figs = self.info_to_plots(self.env_outputs['info'])
        self.env_outputs['series'] = env_series
        self.env_outputs['figs'] = env_figs

    def info_to_plots(self, info_dict):
        """
        Takes the info dictionary and converts the data into pd.Series
        and into plots (one per Series)

        args
            info_dict (dict) either env.info or agent.memory.info
        """
        data_dict, figs_dict = {}, {}

        for var, data in info_dict.items():

            #  don't use next state as terminal state is a string
            if var != 'next_state' and var != 'next_observation':

                if isinstance(data[0], np.ndarray):
                    logger.debug('making df for {} from info dict'.format(var))
                    data = [array.flatten() for array in data]
                    names = ['{}_{}'.format(var,i) for i in range(len(data))]
                    data = pd.DataFrame.from_items(zip(names, data))

                else:
                    logger.debug('making series for {} from info dict'.format(var))
                    data = pd.Series(data, name=var)

                data_dict[var] = data 
                #  then create the figure and save into figs_dict
                fig_name = os.path.join('figs', var)
                single_series_fig(data, fig_name, self.results_path)

        return data_dict, figs_dict

    def write_data_to_disk(self):
        disk_data = {'df_stp.csv': self.agent_outputs['df_stp'],
                     'df_ep.csv': self.agent_outputs['df_ep'],
                     'env_info.csv': self.env_outputs['df_env_info']}

        for path, data in disk_data.items():
            path = os.path.join(self.results_path, 'csvs', path)
            self.ensure_dir(path)
            data.to_csv(path)

    def output_results(self, save_data):
        """
        Saves figures and data to disk

        args
            save_data (bool): whether to save csvs
        """

        #  reward panel is shared between all environments
        #  it uses only reinforcement learning data (reward)
        reward_panel = {'name': 'reward_panel',
                        'panels': [['reward', 'cum max reward'],
                                   ['rolling mean']],
                        'errors': [[], ['rolling std']],
                        'xlabel': 'Episode',
                        'ylabels': ['Total undiscounted reward per episode',
                                    'Rolling last 10% of episodes'],
                        'results_path': self.results_path}

        #  add the dataframe with the data for this plot
        reward_panel['df'] = self.agent_outputs['df_ep']

        #  create the figure
        make_panel_fig(**reward_panel)

        env_panel_fig = self.env_outputs['env_panel_fig']
        if env_panel_fig:
            #  now we make any environment specific panel figures
            env_panel_fig['df'] = self.env_outputs['df_env_info']
            name = env_panel_fig['name']
            make_panel_fig(**env_panel_fig)

        if save_data:
            self.write_data_to_disk()

        return self.agent_outputs, self.env_outputs
