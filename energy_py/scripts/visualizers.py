"""
"""

import collections
import logging
import itertools
import os

import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from energy_py.scripts.utils import Utils

matplotlib.rcParams['agg.path.chunksize'] = 10000


class EternityVisualizer(Utils):
    """
    A class to join together data generated by the agent and environment
    """
    def __init__(self,
                 agent,
                 env,
                 results_path='results/'):

        super().__init__()

        self.env = env
        self.agent = agent

        self.results_path = os.path.join(results_path)

        print('pulling data out of the environment')
        self.env_outputs = self.env.output_results()

        #  using the index from state_ts to index the env_info dataframe
        index = self.env_outputs['state_ts'].index
        self.env_outputs['df_env_info'].index = index

        print('pulling data out of the agent')
        self.agent_outputs = self.agent.output_results()

        #  now we grab the .info dictionaries from both agent and env
        #  and turn them into plots
        agent_series, agent_figs = self.info_to_plots(self.agent_outputs['info'])
        self.agent_outputs['series'] = agent_series
        self.agent_outputs['figs'] = agent_figs

        env_series, env_figs = self.info_to_plots(self.env_outputs['info'])
        self.env_outputs['series'] = env_series
        self.env_outputs['figs'] = env_figs

    def make_time_series_fig(self, 
                             series,
                             name,
                             xlabel=[],
                             ylabel=[],
                             xlim='all',
                             ylim=[]):
        """
        makes a time series figure from a pd.Series and specified columns
        """

        fig, ax = plt.subplots(1, 1, figsize=(20, 20))
        data = series.astype(float)
        data.plot(kind='line', ax=ax)

        if ylim:
            ax.set_ylim(ylim)

        if xlabel:
            plt.xlabel(xlabel)

        if ylabel:
            plt.ylabel(ylabel)

        plt.legend()

        if xlim == 'last_week':
            start = series.index[-7 * 24 * 12]
            end = series.index[-1]

        if xlim == 'last_month':
            start = series.index[-30 * 24 * 12]
            end = series.index[-1]

        if xlim == 'all':
            start = series.index[0]
            end = series.index[-1]

        ax.set_xlim([start, end])

        if name:
            path = os.path.join(self.results_path, name+'.png')
            self.ensure_dir(path)
            fig.savefig(path)

        return fig

    def make_panel_fig(self, 
                       df,
                       panels,
                       shape,
                       name,
                       xlim='all',
                       ylabels=[],
                       xlabel=[],
                       ylims=[],
                       kinds=[],
                       errors=[]):
        """
        makes a panel of time series figures
        """
        num_panels = len(panels)
        print('making panel fig with {} panels - shape {}'.format(num_panels,
                                                                  shape))
        if xlabel:
            xlabels = [xlabel for i in range(num_panels)]
            assert num_panels == len(xlabels)
        assert shape[0] * shape[1] == num_panels 

        fig, axes = plt.subplots(nrows=shape[0],
                                 ncols=shape[1],
                                 figsize=(20, 20),
                                 sharex=True)
        for i, (ax, panel) in enumerate(zip(axes.flatten(),
                                            panels)):

            for col in panel:
                data = df.loc[:, col]
                
                if kinds:
                    kind = kinds[i]
                else:
                    kind = 'line'

                data.plot(kind=kind, ax=ax, label=col)

                if errors and errors[i]:
                    x = df.index.values
                    y = data.values
                    error = df.loc[:, errors[i]].values.flatten()
                    ax.fill_between(x, y - error, y + error,
                                    alpha=0.5)

                if ylims and ylims[i]:
                    ax.set_ylim(ylims[i])

                if xlabel:
                    ax.set_xlabel(xlabels[i])

                if ylabels: 
                    assert num_panels == len(ylabels)
                    ax.set_ylabel(ylabels[i])

                ax.legend()

                # if xlim == 'last_week':
                #     start = df.index[-7 * 24 * 12]
                #     end = df.index[-1]

                # if xlim == 'last_month':
                #     start = df.index[-30 * 24 * 12]
                #     end = df.index[-1]

                # if xlim == 'all':
                #     start = df.index[0]
                #     end = df.index[-1]

                # ax.set_xlim([start, end])

            if name:
                path = os.path.join(self.results_path, name+'.png')
                self.ensure_dir(path)
                fig.savefig(path)

        return fig

    def info_to_plots(self, info_dict):
        """
        Takes the info dictionary and converts the data into pd.Series
        and into plots (one per Series)

        args
            info_dict (dict) either env.info or agent.memory.info
        """
        data_dict, figs_dict = {}, {}

        for var, data in info_dict.items():
            
            #  don't use next state as terminal state is a string
            if var != 'next_state' and var != 'next_observation':

                if isinstance(data[0], np.ndarray):
                    logging.info('making df for {} from info dict'.format(var))
                    length = data[0].shape[1]
                    data = [array.flatten() for array in data]
                    names = ['{}_{}'.format(var,i) for i in range(length)]
                    data = pd.DataFrame.from_items(zip(names, data))

                else:
                    logging.info('making series for {} from info dict'.format(var))
                    data = pd.Series(data, name=var)

                data_dict[var] = data 
                #  then create the figure and save into figs_dict
                fig_path = os.path.join(self.results_path, var+'.png')
                figs_dict[var] = self.make_time_series_fig(data, fig_path)

        return data_dict, figs_dict

    def write_data_to_disk(self):
        disk_data = {'df_stp.csv': self.agent_outputs['df_stp'],
                     'df_ep.csv': self.agent_outputs['df_ep'],
                     'env_info.csv': self.env_outputs['df_env_info']}

        for path, data in disk_data.items():
            path = os.path.join(self.results_path, 'csvs', path)
            self.ensure_dir(path)
            data.to_csv(path)

    def output_results(self, save_data):
        """
        """

        #  reward panel is shared between all environments
        #  it uses only reinforcement learning data (reward)
        reward_panel = {'name': 'reward_panel',
                        'panels': [['reward', 'cum max reward'],
                                   ['rolling mean']],
                        'errors': [[], ['rolling std']],
                        'xlabel': 'Episode',
                        'ylabels': ['Total undiscounted reward per episode',
                                    'Rolling last 10% of episodes'],
                        'shape': (2,1)}

        #  add the dataframe with the data for this plot
        reward_panel['df'] = self.agent_outputs['df_ep']

        #  create the figure
        self.env_outputs['figs']['reward_pnl'] = self.make_panel_fig(**reward_panel)

        env_panel_fig = self.env_outputs['env_panel_fig']
        if env_panel_fig:
            #  now we make any environment specific panel figures
            env_panel_fig['df'] = self.env_outputs['df_env_info']
            name = env_panel_fig['name']
            self.env_outputs['figs'][name] = self.make_panel_fig(**env_panel_fig)

        if save_data:
            self.write_data_to_disk()

        return self.agent_outputs, self.env_outputs
